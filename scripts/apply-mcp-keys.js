#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath, pathToFileURL } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..');
const keysPath = path.resolve(repoRoot, 'API_KEYS_MASTER.js');

const SUPPORTED_KEYS = [
  'MCP_SERVER_URL',
  'MCP_TOKEN',
  'API_BASE_URL',
  'SPORTSDATAIO_API_KEY',
  'MLB_API_KEY',
  'NFL_API_KEY',
  'NBA_API_KEY',
  'NCAA_API_KEY',
  'PERFECT_GAME_API_KEY',
  'KINTRAX_API_KEY',
  'DB_HOST',
  'DB_PORT',
  'DB_NAME',
  'DB_USER',
  'DB_PASSWORD',
  'REDIS_URL',
  'REDIS_HOST',
  'REDIS_PORT',
  'REDIS_PASSWORD',
  'EMAIL_API_KEY',
  'INTERNAL_API_KEY',
  'POSTHOG_API_KEY',
  'SENTRY_DSN'
];

const REQUIRED_KEYS = ['MCP_SERVER_URL', 'MCP_TOKEN'];

function collectStringEntries(value, pathSegments = [], acc = []) {
  if (value === null || value === undefined) {
    return acc;
  }

  if (typeof value === 'string') {
    acc.push({ path: pathSegments, value });
    return acc;
  }

  if (Array.isArray(value)) {
    value.forEach((item, index) => {
      collectStringEntries(item, [...pathSegments, String(index)], acc);
    });
    return acc;
  }

  if (typeof value === 'object') {
    Object.entries(value).forEach(([key, child]) => {
      collectStringEntries(child, [...pathSegments, key], acc);
    });
  }

  return acc;
}

function normalize(segment) {
  return segment.replace(/[^A-Za-z0-9]/g, '_').toUpperCase();
}

function buildValueMap(entries) {
  const map = new Map();

  for (const entry of entries) {
    const lastSegment = entry.path[entry.path.length - 1];
    if (!lastSegment) {
      continue;
    }

    const normalizedKey = normalize(lastSegment);
    if (!map.has(normalizedKey)) {
      map.set(normalizedKey, entry.value);
    }
  }

  return map;
}

function maskValue(value) {
  if (!value) {
    return '***';
  }

  if (value.length <= 6) {
    return '*'.repeat(Math.max(1, value.length));
  }

  return `${value.slice(0, 2)}***${value.slice(-2)}`;
}

function escapeEnv(value) {
  if (/\s|#|"|'|`/.test(value)) {
    return JSON.stringify(value);
  }

  return value;
}

function escapeToml(value) {
  return value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
}

async function writeEnvFile(envValues) {
  const envPath = path.resolve(repoRoot, 'config', 'mcp.env');
  await fs.mkdir(path.dirname(envPath), { recursive: true });

  const header = '# Generated by scripts/apply-mcp-keys.js\n';
  const body = Object.entries(envValues)
    .map(([key, value]) => `${key}=${escapeEnv(value)}`)
    .join('\n');

  await fs.writeFile(envPath, `${header}${body}\n`, { mode: 0o600 });
  return envPath;
}

async function writeWranglerLocal(envValues) {
  const sourcePath = path.resolve(repoRoot, 'wrangler-championship.toml');
  const targetPath = path.resolve(repoRoot, 'wrangler-championship.local.toml');

  try {
    const template = await fs.readFile(sourcePath, 'utf8');
    let output = template;

    ['MCP_SERVER_URL', 'MCP_TOKEN', 'API_BASE_URL'].forEach((key) => {
      if (!envValues[key]) {
        return;
      }

      const pattern = new RegExp(`${key}\\s*=\\s*".*?"`);
      output = output.replace(pattern, `${key} = "${escapeToml(envValues[key])}"`);
    });

    await fs.writeFile(targetPath, output, { mode: 0o600 });
    return targetPath;
  } catch (error) {
    if (error.code === 'ENOENT') {
      return null;
    }

    throw error;
  }
}

async function loadKeys() {
  try {
    await fs.access(keysPath);
  } catch {
    throw new Error(`API key source not found at ${keysPath}`);
  }

  const module = await import(pathToFileURL(keysPath).href);
  const keysData = module?.default ?? module?.keys ?? module;

  if (!keysData || typeof keysData !== 'object') {
    throw new Error('API_KEYS_MASTER.js did not export an object');
  }

  return keysData;
}

async function main() {
  try {
    const keysData = await loadKeys();
    const entries = collectStringEntries(keysData);
    const values = buildValueMap(entries);

    const envValues = {};
    SUPPORTED_KEYS.forEach((key) => {
      if (values.has(key)) {
        envValues[key] = values.get(key);
      }
    });

    const missingRequired = REQUIRED_KEYS.filter((key) => !envValues[key]);
    if (missingRequired.length > 0) {
      throw new Error(`Missing required keys: ${missingRequired.join(', ')}`);
    }

    const envPath = await writeEnvFile(envValues);
    const wranglerPath = await writeWranglerLocal(envValues);

    console.log(`‚úÖ MCP environment values written to ${envPath}`);
    if (wranglerPath) {
      console.log(`‚úÖ Local Wrangler config generated at ${wranglerPath}`);
    } else {
      console.warn('‚ö†Ô∏è wrangler-championship.toml not found; skipped local config generation.');
    }

    const maskedSummary = Object.entries(envValues)
      .map(([key, value]) => `${key}=${maskValue(value)}`)
      .join(', ');
    console.log(`üîê Synced keys: ${maskedSummary}`);
  } catch (error) {
    console.error('‚ùå Failed to apply MCP keys:', error.message);
    process.exitCode = 1;
  }
}

main();
