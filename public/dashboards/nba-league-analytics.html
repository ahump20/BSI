<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üèÄ NBA League Analytics | Blaze Intelligence</title>
  <meta name="description" content="Comprehensive NBA analytics for all 30 teams - objective data, zero bias, powered by Blaze Intelligence">

  <!-- Chart.js for Data Visualization -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <!-- Font Awesome Icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      /* Blaze Intelligence System Colors (Neutral - No Team Bias) */
      --blaze-burnt-orange: #BF5700;
      --blaze-ember: #CC6600;
      --blaze-background: #0a0a0a;
      --blaze-surface: rgba(26, 26, 26, 0.6);
      --blaze-text: #e0e0e0;
      --blaze-text-dim: #a0a0a0;
      --blaze-success: #4ade80;
      --blaze-warning: #f59e0b;
      --blaze-danger: #f87171;
      --blaze-info: #60a5fa;

      /* Glass Morphism Effects */
      --glass-light: rgba(191, 87, 0, 0.08);
      --glass-medium: rgba(191, 87, 0, 0.12);
      --glass-heavy: rgba(191, 87, 0, 0.18);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0f0f0f 100%);
      color: var(--blaze-text);
      min-height: 100vh;
      padding: 2rem;
      line-height: 1.6;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    /* Header Styling */
    header {
      text-align: center;
      margin-bottom: 3rem;
      padding: 2rem;
      background: var(--glass-medium);
      backdrop-filter: blur(16px) saturate(180%);
      border-radius: 20px;
      border: 1px solid rgba(191, 87, 0, 0.2);
      box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--blaze-burnt-orange) 0%, var(--blaze-ember) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5rem;
    }

    .subtitle {
      font-size: 1.1rem;
      color: var(--blaze-text-dim);
      margin-bottom: 0.5rem;
    }

    .tagline {
      font-size: 0.9rem;
      color: var(--blaze-burnt-orange);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: 0.5rem;
    }

    .league-badges {
      display: flex;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    .league-badge {
      background: var(--glass-light);
      padding: 0.5rem 1rem;
      border-radius: 12px;
      font-size: 0.85rem;
      border: 1px solid rgba(191, 87, 0, 0.15);
    }

    /* Filter Bar */
    .filter-bar {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-bottom: 2rem;
      padding: 1rem;
      background: var(--glass-medium);
      backdrop-filter: blur(16px) saturate(180%);
      border-radius: 16px;
      border: 1px solid rgba(191, 87, 0, 0.2);
    }

    .filter-btn {
      padding: 0.6rem 1.2rem;
      background: var(--glass-light);
      border: 1px solid rgba(191, 87, 0, 0.2);
      color: var(--blaze-text);
      border-radius: 10px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .filter-btn:hover {
      background: var(--glass-medium);
      border-color: var(--blaze-burnt-orange);
      transform: translateY(-2px);
    }

    .filter-btn.active {
      background: linear-gradient(135deg, var(--blaze-burnt-orange) 0%, var(--blaze-ember) 100%);
      border-color: var(--blaze-burnt-orange);
      color: white;
      box-shadow: 0 4px 16px rgba(191, 87, 0, 0.4);
    }

    /* Cards Grid */
    .cards-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
      gap: 2rem;
      margin-bottom: 2rem;
    }

    .analytics-card {
      background: var(--glass-medium);
      backdrop-filter: blur(16px) saturate(180%);
      border-radius: 20px;
      padding: 2rem;
      border: 1px solid rgba(191, 87, 0, 0.2);
      box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
      transition: all 0.3s ease;
    }

    .analytics-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 48px 0 rgba(191, 87, 0, 0.3);
      border-color: var(--blaze-burnt-orange);
    }

    .card-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid rgba(191, 87, 0, 0.2);
    }

    .card-icon {
      font-size: 1.5rem;
      color: var(--blaze-burnt-orange);
    }

    .card-title {
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--blaze-text);
    }

    /* Table Styling */
    .standings-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }

    .standings-table thead {
      background: var(--glass-heavy);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .standings-table th {
      padding: 0.75rem;
      text-align: left;
      font-weight: 600;
      color: var(--blaze-burnt-orange);
      text-transform: uppercase;
      font-size: 0.75rem;
      letter-spacing: 0.5px;
      border-bottom: 2px solid rgba(191, 87, 0, 0.3);
    }

    .standings-table td {
      padding: 0.75rem;
      border-bottom: 1px solid rgba(191, 87, 0, 0.1);
    }

    .standings-table tbody tr {
      transition: all 0.2s ease;
    }

    .standings-table tbody tr:hover {
      background: var(--glass-light);
      transform: scale(1.01);
    }

    .text-center {
      text-align: center !important;
    }

    .text-success {
      color: var(--blaze-success) !important;
    }

    .text-danger {
      color: var(--blaze-danger) !important;
    }

    .text-warning {
      color: var(--blaze-warning) !important;
    }

    .text-info {
      color: var(--blaze-info) !important;
    }

    /* Chart Container */
    .chart-container {
      position: relative;
      height: 400px;
      margin: 1.5rem 0;
    }

    /* Loading State */
    .loading {
      text-align: center;
      padding: 3rem;
      font-size: 1.1rem;
      color: var(--blaze-text-dim);
    }

    .spinner {
      display: inline-block;
      width: 40px;
      height: 40px;
      border: 4px solid rgba(191, 87, 0, 0.3);
      border-top-color: var(--blaze-burnt-orange);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 1rem;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Error State */
    .error-message {
      background: rgba(248, 113, 113, 0.1);
      border: 1px solid var(--blaze-danger);
      border-radius: 12px;
      padding: 1.5rem;
      margin: 1rem 0;
      color: var(--blaze-danger);
    }

    /* Footer */
    footer {
      text-align: center;
      padding: 2rem;
      margin-top: 3rem;
      color: var(--blaze-text-dim);
      font-size: 0.9rem;
      border-top: 1px solid rgba(191, 87, 0, 0.2);
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }

      h1 {
        font-size: 1.8rem;
      }

      .cards-grid {
        grid-template-columns: 1fr;
      }

      .filter-bar {
        padding: 0.5rem;
      }

      .filter-btn {
        padding: 0.4rem 0.8rem;
        font-size: 0.8rem;
      }

      .standings-table {
        font-size: 0.75rem;
      }

      .standings-table th,
      .standings-table td {
        padding: 0.5rem 0.25rem;
      }

      .chart-container {
        height: 300px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üèÄ NBA League Analytics</h1>
      <p class="subtitle">Complete National Basketball Association Intelligence ‚Ä¢ All 30 Teams ‚Ä¢ 2025-26 Season</p>
      <p class="tagline">Objective Analytics ‚Ä¢ Zero Bias ‚Ä¢ Pure Data</p>
      <div class="league-badges">
        <span class="league-badge">üìä 30 Teams ‚Ä¢ 82 Games</span>
        <span class="league-badge">üî¢ Pythagorean Exponent: 13.91</span>
        <span class="league-badge">üì° ESPN API</span>
      </div>
    </header>

    <!-- Live Scoreboard Section -->
    <div class="analytics-card" style="margin-bottom: 2rem;">
      <div class="card-header">
        <i class="fas fa-satellite-dish card-icon"></i>
        <h2 class="card-title">Today's Games</h2>
        <span id="games-update-time" style="margin-left: auto; font-size: 0.75rem; color: var(--blaze-text-dim);"></span>
      </div>
      <div id="live-games-container">
        <div class="loading">
          <div class="spinner"></div>
          <p>Loading today's games...</p>
        </div>
      </div>
    </div>

    <!-- Filter Bar -->
    <div class="filter-bar">
      <button class="filter-btn active" data-filter="all">All Teams</button>
      <button class="filter-btn" data-filter="Eastern">Eastern Conference</button>
      <button class="filter-btn" data-filter="Western">Western Conference</button>
      <button class="filter-btn" data-filter="Atlantic">Atlantic</button>
      <button class="filter-btn" data-filter="Central">Central</button>
      <button class="filter-btn" data-filter="Southeast">Southeast</button>
      <button class="filter-btn" data-filter="Northwest">Northwest</button>
      <button class="filter-btn" data-filter="Pacific">Pacific</button>
      <button class="filter-btn" data-filter="Southwest">Southwest</button>
    </div>

    <!-- Analytics Cards -->
    <div class="cards-grid">
      <!-- Card 1: Standings Table -->
      <div class="analytics-card" style="grid-column: 1 / -1;">
        <div class="card-header">
          <i class="fas fa-table card-icon"></i>
          <h2 class="card-title">NBA Standings</h2>
        </div>
        <div id="standings-container">
          <div class="loading">
            <div class="spinner"></div>
            <p>Loading NBA standings data...</p>
          </div>
        </div>
      </div>

      <!-- Card 2: Pythagorean Expectation Scatter Plot -->
      <div class="analytics-card">
        <div class="card-header">
          <i class="fas fa-chart-scatter card-icon"></i>
          <h2 class="card-title">Pythagorean Analysis</h2>
        </div>
        <div class="chart-container">
          <canvas id="pythagorean-chart"></canvas>
        </div>
        <p style="font-size: 0.85rem; color: var(--blaze-text-dim); margin-top: 1rem;">
          Teams above the line are winning more than expected (lucky), below are underperforming (unlucky).
        </p>
      </div>

      <!-- Card 3: Net Rating Bar Chart -->
      <div class="analytics-card">
        <div class="card-header">
          <i class="fas fa-chart-bar card-icon"></i>
          <h2 class="card-title">Net Rating Analysis</h2>
        </div>
        <div class="chart-container">
          <canvas id="netrating-chart"></canvas>
        </div>
        <p style="font-size: 0.85rem; color: var(--blaze-text-dim); margin-top: 1rem;">
          Net rating = Points per game scored minus points per game allowed.
        </p>
      </div>

      <!-- Card 4: Playoff Probability -->
      <div class="analytics-card" style="grid-column: 1 / -1;">
        <div class="card-header">
          <i class="fas fa-trophy card-icon"></i>
          <h2 class="card-title">Playoff Probability</h2>
        </div>
        <div class="chart-container" style="height: 600px;">
          <canvas id="playoff-chart"></canvas>
        </div>
        <p style="font-size: 0.85rem; color: var(--blaze-text-dim); margin-top: 1rem;">
          Probability based on current pace, remaining schedule strength, and Pythagorean expectation. Top 8 teams per conference make playoffs.
        </p>
      </div>
    </div>

    <footer>
      <p>&copy; 2025 Blaze Intelligence ‚Ä¢ NBA Analytics Platform</p>
      <p style="margin-top: 0.5rem;">Data powered by ESPN API ‚Ä¢ Updated in real-time</p>
    </footer>
  </div>

  <script type="module">
    // Configuration - Using ESPN's free API
    const ESPN_BASE = 'https://site.api.espn.com/apis/site/v2/sports/basketball/nba';

    // Filter state
    let currentFilter = 'all';
    let allStandingsData = null;

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      setupFilterButtons();
      loadLiveGames();
      loadStandingsData();

      // Auto-refresh live games every 30 seconds
      setInterval(loadLiveGames, 30000);
    });

    // Load live games and scores from ESPN
    async function loadLiveGames() {
      const container = document.getElementById('live-games-container');
      const updateTime = document.getElementById('games-update-time');

      try {
        const response = await fetch(`${ESPN_BASE}/scoreboard`);
        if (!response.ok) throw new Error('Failed to fetch games');

        const data = await response.json();
        const events = data.events || [];

        // Update timestamp
        const now = new Date();
        updateTime.textContent = `Updated: ${now.toLocaleTimeString('en-US', { timeZone: 'America/Chicago', hour: '2-digit', minute: '2-digit' })} CT`;

        if (events.length === 0) {
          container.innerHTML = `
            <div style="text-align: center; padding: 2rem; color: var(--blaze-text-dim);">
              <i class="fas fa-basketball" style="font-size: 2rem; margin-bottom: 1rem; display: block; opacity: 0.5;"></i>
              <p>No games scheduled for today</p>
              <p style="font-size: 0.85rem; margin-top: 0.5rem;">Check back on game days for live scores</p>
            </div>
          `;
          return;
        }

        // Separate live, final, and upcoming games
        const liveGames = events.filter(e => e.status?.type?.state === 'in');
        const finalGames = events.filter(e => e.status?.type?.state === 'post');
        const upcomingGames = events.filter(e => e.status?.type?.state === 'pre');

        let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1rem;">';

        // Render live games first
        liveGames.forEach(event => {
          html += renderGameCard(event, 'live');
        });

        // Then final games
        finalGames.forEach(event => {
          html += renderGameCard(event, 'final');
        });

        // Then upcoming games
        upcomingGames.forEach(event => {
          html += renderGameCard(event, 'upcoming');
        });

        html += '</div>';
        container.innerHTML = html;

      } catch (error) {
        console.error('Error loading live games:', error);
        container.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: var(--blaze-text-dim);">
            <i class="fas fa-wifi" style="font-size: 2rem; margin-bottom: 1rem; display: block; opacity: 0.5;"></i>
            <p>Unable to load live games</p>
            <p style="font-size: 0.85rem; margin-top: 0.5rem;">ESPN data temporarily unavailable</p>
          </div>
        `;
      }
    }

    // Render individual game card
    function renderGameCard(event, status) {
      const competition = event.competitions?.[0];
      if (!competition) return '';

      const homeTeam = competition.competitors?.find(c => c.homeAway === 'home');
      const awayTeam = competition.competitors?.find(c => c.homeAway === 'away');

      if (!homeTeam || !awayTeam) return '';

      const homeName = homeTeam.team?.shortDisplayName || homeTeam.team?.displayName || 'Home';
      const awayName = awayTeam.team?.shortDisplayName || awayTeam.team?.displayName || 'Away';
      const homeScore = homeTeam.score || '0';
      const awayScore = awayTeam.score || '0';

      let statusText = '';
      let statusColor = 'var(--blaze-text-dim)';
      let borderColor = 'rgba(191, 87, 0, 0.2)';

      if (status === 'live') {
        const detail = event.status?.type?.detail || 'In Progress';
        statusText = `üî¥ ${detail}`;
        statusColor = 'var(--blaze-danger)';
        borderColor = 'var(--blaze-danger)';
      } else if (status === 'final') {
        statusText = 'Final';
        statusColor = 'var(--blaze-success)';
      } else {
        const gameDate = new Date(event.date);
        statusText = gameDate.toLocaleTimeString('en-US', { timeZone: 'America/Chicago', hour: 'numeric', minute: '2-digit' }) + ' CT';
      }

      const homeWinner = status !== 'upcoming' && parseInt(homeScore) > parseInt(awayScore);
      const awayWinner = status !== 'upcoming' && parseInt(awayScore) > parseInt(homeScore);

      return `
        <div style="background: var(--glass-light); border-radius: 12px; padding: 1rem; border: 1px solid ${borderColor};">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <span style="font-size: 0.7rem; color: ${statusColor}; font-weight: 600; text-transform: uppercase;">${statusText}</span>
            ${event.broadcasts?.[0]?.names?.[0] ? `<span style="font-size: 0.65rem; color: var(--blaze-text-dim);">${event.broadcasts[0].names[0]}</span>` : ''}
          </div>
          <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; ${awayWinner ? 'font-weight: 700;' : ''}">
              <span style="font-size: 0.9rem;">${awayName}</span>
              <span style="font-size: 1.1rem; font-weight: 600; ${awayWinner ? 'color: var(--blaze-success);' : ''}">${status === 'upcoming' ? '-' : awayScore}</span>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; ${homeWinner ? 'font-weight: 700;' : ''}">
              <span style="font-size: 0.9rem;">${homeName}</span>
              <span style="font-size: 1.1rem; font-weight: 600; ${homeWinner ? 'color: var(--blaze-success);' : ''}">${status === 'upcoming' ? '-' : homeScore}</span>
            </div>
          </div>
        </div>
      `;
    }

    // Filter button handlers
    function setupFilterButtons() {
      const buttons = document.querySelectorAll('.filter-btn');
      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          buttons.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentFilter = btn.dataset.filter;
          if (allStandingsData) {
            renderAllVisualizations(allStandingsData);
          }
        });
      });
    }

    // Load standings data from ESPN API (v2 endpoint has full data)
    async function loadStandingsData() {
      try {
        const response = await fetch('https://site.api.espn.com/apis/v2/sports/basketball/nba/standings');

        if (!response.ok) {
          throw new Error(`API error: ${response.statusText}`);
        }

        const data = await response.json();
        allStandingsData = processStandingsData(data);
        renderAllVisualizations(allStandingsData);
      } catch (error) {
        console.error('Error loading standings:', error);
        showError('Failed to load NBA standings data. Using demo data for visualization.');
        // Fallback to demo data
        allStandingsData = generateDemoData();
        renderAllVisualizations(allStandingsData);
      }
    }

    // Process ESPN v2 API response into our format
    function processStandingsData(apiData) {
      const allTeams = [];

      // ESPN v2 returns standings by conference directly in children array
      apiData.children?.forEach(conference => {
        const confName = conference.name; // "Eastern Conference" or "Western Conference"
        const confShort = confName.includes('Eastern') ? 'Eastern' : 'Western';

        // Standings entries are directly under conference.standings.entries
        conference.standings?.entries?.forEach(entry => {
          const team = entry.team;
          const stats = entry.stats || [];

          // Helper to get stat value
          const getStat = (name) => stats.find(s => s.name === name);

          const wins = getStat('wins')?.value || 0;
          const losses = getStat('losses')?.value || 0;
          const gamesPlayed = wins + losses;
          const winPct = getStat('winPercent')?.value || (gamesPlayed > 0 ? wins / gamesPlayed : 0);
          const gamesBack = getStat('gamesBehind')?.value || 0;

          const avgPointsFor = getStat('avgPointsFor')?.value || 0;
          const avgPointsAgainst = getStat('avgPointsAgainst')?.value || 0;
          const pointsFor = avgPointsFor * gamesPlayed;
          const pointsAgainst = avgPointsAgainst * gamesPlayed;

          const streak = getStat('streak')?.displayValue || '-';
          const playoffSeed = getStat('playoffSeed')?.value || 999;

          // Get division from divisionRecord stat name pattern or team location
          const divRecord = getStat('divisionRecord')?.displayValue || '-';

          const pythag = calculatePythagorean(pointsFor, pointsAgainst, gamesPlayed, wins);

          allTeams.push({
            rank: playoffSeed,
            team: {
              id: team.id,
              name: team.displayName,
              shortName: team.shortDisplayName,
              abbreviation: team.abbreviation,
              logo: team.logos?.[0]?.href
            },
            conference: confShort,
            division: getDivisionFromTeam(team.displayName),
            record: {
              wins,
              losses,
              winPercentage: winPct,
              gamesBack
            },
            homeRecord: getStat('Home')?.displayValue || getStat('homeRecord')?.displayValue || '-',
            awayRecord: getStat('Road')?.displayValue || getStat('awayRecord')?.displayValue || '-',
            conferenceRecord: getStat('vsConf')?.displayValue || getStat('conferenceRecord')?.displayValue || '-',
            divisionRecord: divRecord,
            lastTenRecord: getStat('L10')?.displayValue || getStat('streak')?.displayValue || '-',
            streak,
            pointsFor,
            pointsAgainst,
            avgPointsFor,
            avgPointsAgainst,
            netRating: (avgPointsFor - avgPointsAgainst).toFixed(1),
            pythag
          });
        });
      });

      // Sort by conference then by playoff seed
      allTeams.sort((a, b) => {
        if (a.conference !== b.conference) {
          return a.conference === 'Eastern' ? -1 : 1;
        }
        return a.rank - b.rank;
      });

      return allTeams;
    }

    // Map team names to divisions
    function getDivisionFromTeam(teamName) {
      const divisionMap = {
        // Atlantic
        'Boston Celtics': 'Atlantic', 'Brooklyn Nets': 'Atlantic', 'New York Knicks': 'Atlantic',
        'Philadelphia 76ers': 'Atlantic', 'Toronto Raptors': 'Atlantic',
        // Central
        'Chicago Bulls': 'Central', 'Cleveland Cavaliers': 'Central', 'Detroit Pistons': 'Central',
        'Indiana Pacers': 'Central', 'Milwaukee Bucks': 'Central',
        // Southeast
        'Atlanta Hawks': 'Southeast', 'Charlotte Hornets': 'Southeast', 'Miami Heat': 'Southeast',
        'Orlando Magic': 'Southeast', 'Washington Wizards': 'Southeast',
        // Northwest
        'Denver Nuggets': 'Northwest', 'Minnesota Timberwolves': 'Northwest', 'Oklahoma City Thunder': 'Northwest',
        'Portland Trail Blazers': 'Northwest', 'Utah Jazz': 'Northwest',
        // Pacific
        'Golden State Warriors': 'Pacific', 'LA Clippers': 'Pacific', 'Los Angeles Lakers': 'Pacific',
        'Phoenix Suns': 'Pacific', 'Sacramento Kings': 'Pacific',
        // Southwest
        'Dallas Mavericks': 'Southwest', 'Houston Rockets': 'Southwest', 'Memphis Grizzlies': 'Southwest',
        'New Orleans Pelicans': 'Southwest', 'San Antonio Spurs': 'Southwest'
      };
      return divisionMap[teamName] || 'Unknown';
    }

    // Calculate Pythagorean expectation (NBA uses exponent 13.91)
    function calculatePythagorean(pointsFor, pointsAgainst, gamesPlayed, actualWins) {
      if (pointsFor === 0 && pointsAgainst === 0) {
        return { expectedWins: 0, luckFactor: 0 };
      }

      const exponent = 13.91;
      const pythagPercent = Math.pow(pointsFor, exponent) /
        (Math.pow(pointsFor, exponent) + Math.pow(pointsAgainst, exponent));

      const expectedWins = pythagPercent * gamesPlayed;
      const luckFactor = actualWins - expectedWins;

      return {
        expectedWins: parseFloat(expectedWins.toFixed(1)),
        luckFactor: parseFloat(luckFactor.toFixed(1))
      };
    }

    // Filter teams based on current filter
    function filterTeams(teams) {
      if (currentFilter === 'all') {
        return teams;
      }

      if (currentFilter === 'Eastern' || currentFilter === 'Western') {
        return teams.filter(t => t.conference === currentFilter);
      }

      // Filter by division name
      return teams.filter(t => t.division === currentFilter);
    }

    // Render all visualizations
    function renderAllVisualizations(standings) {
      const filteredTeams = filterTeams(standings);
      renderStandingsTable(filteredTeams);
      renderPythagoreanChart(filteredTeams);
      renderNetRatingChart(filteredTeams);
      renderPlayoffProbabilityChart(filteredTeams);
    }

    // Render standings table
    function renderStandingsTable(teams) {
      const container = document.getElementById('standings-container');

      if (teams.length === 0) {
        container.innerHTML = '<p class="loading">No teams found for selected filter.</p>';
        return;
      }

      const html = `
        <div style="overflow-x: auto;">
          <table class="standings-table">
            <thead>
              <tr>
                <th class="text-center">Seed</th>
                <th>Team</th>
                <th class="text-center">Conf</th>
                <th class="text-center">Div</th>
                <th class="text-center">W</th>
                <th class="text-center">L</th>
                <th class="text-center">Win%</th>
                <th class="text-center">GB</th>
                <th class="text-center">PPG</th>
                <th class="text-center">OPP PPG</th>
                <th class="text-center">Net Rtg</th>
                <th class="text-center">Streak</th>
                <th class="text-center">L10</th>
              </tr>
            </thead>
            <tbody>
              ${teams.map((team, index) => {
                // Handle streak as string (e.g., "W3" or "L2")
                const streakStr = typeof team.streak === 'string' ? team.streak : `${team.streak?.type || '-'}${team.streak?.count || ''}`;
                const streakClass = streakStr.startsWith('W') ? 'text-success' : streakStr.startsWith('L') ? 'text-danger' : '';
                const netRatingClass = parseFloat(team.netRating) > 0 ? 'text-success' : 'text-danger';
                const avgPF = team.avgPointsFor ? team.avgPointsFor.toFixed(1) : (team.pointsFor / (team.record.wins + team.record.losses)).toFixed(1);
                const avgPA = team.avgPointsAgainst ? team.avgPointsAgainst.toFixed(1) : (team.pointsAgainst / (team.record.wins + team.record.losses)).toFixed(1);

                return `
                  <tr>
                    <td class="text-center"><strong>${team.rank < 999 ? team.rank : '-'}</strong></td>
                    <td><strong>${team.team.name}</strong></td>
                    <td class="text-center">${team.conference}</td>
                    <td class="text-center">${team.division}</td>
                    <td class="text-center"><strong>${team.record.wins}</strong></td>
                    <td class="text-center">${team.record.losses}</td>
                    <td class="text-center">${(team.record.winPercentage * 100).toFixed(1)}%</td>
                    <td class="text-center">${team.record.gamesBack || '-'}</td>
                    <td class="text-center">${avgPF}</td>
                    <td class="text-center">${avgPA}</td>
                    <td class="text-center ${netRatingClass}"><strong>${parseFloat(team.netRating) > 0 ? '+' : ''}${team.netRating}</strong></td>
                    <td class="text-center ${streakClass}"><strong>${streakStr}</strong></td>
                    <td class="text-center">${team.lastTenRecord}</td>
                  </tr>
                `;
              }).join('')}
            </tbody>
          </table>
        </div>
      `;

      container.innerHTML = html;
    }

    // Render Pythagorean expectation scatter plot
    function renderPythagoreanChart(teams) {
      const ctx = document.getElementById('pythagorean-chart');
      if (!ctx) return;

      // Destroy existing chart if it exists
      const existingChart = Chart.getChart(ctx);
      if (existingChart) {
        existingChart.destroy();
      }

      const data = teams.map(t => ({
        x: t.pythag.expectedWins,
        y: t.record.wins,
        team: t.team.name
      }));

      new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            label: 'Actual vs Expected Wins',
            data: data,
            backgroundColor: 'rgba(191, 87, 0, 0.6)',
            borderColor: 'rgba(191, 87, 0, 1)',
            borderWidth: 2,
            pointRadius: 6,
            pointHoverRadius: 8
          }, {
            label: 'Expected = Actual Line',
            data: [{x: 0, y: 0}, {x: 82, y: 82}],
            type: 'line',
            borderColor: 'rgba(74, 222, 128, 0.5)',
            borderWidth: 2,
            borderDash: [10, 5],
            pointRadius: 0,
            fill: false
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: '#e0e0e0',
                font: { size: 12 }
              }
            },
            tooltip: {
              backgroundColor: 'rgba(26, 26, 26, 0.95)',
              titleColor: '#BF5700',
              bodyColor: '#e0e0e0',
              borderColor: '#BF5700',
              borderWidth: 1,
              padding: 12,
              displayColors: false,
              callbacks: {
                label: function(context) {
                  if (context.datasetIndex === 0) {
                    const point = context.raw;
                    const luck = (point.y - point.x).toFixed(1);
                    return [
                      `Team: ${point.team}`,
                      `Actual Wins: ${point.y}`,
                      `Expected Wins: ${point.x.toFixed(1)}`,
                      `Luck Factor: ${luck > 0 ? '+' : ''}${luck}`
                    ];
                  }
                  return '';
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Expected Wins (Pythagorean)',
                color: '#BF5700',
                font: { size: 14, weight: 'bold' }
              },
              min: 0,
              max: 82,
              grid: {
                color: 'rgba(191, 87, 0, 0.1)'
              },
              ticks: {
                color: '#a0a0a0'
              }
            },
            y: {
              title: {
                display: true,
                text: 'Actual Wins',
                color: '#BF5700',
                font: { size: 14, weight: 'bold' }
              },
              min: 0,
              max: 82,
              grid: {
                color: 'rgba(191, 87, 0, 0.1)'
              },
              ticks: {
                color: '#a0a0a0'
              }
            }
          }
        }
      });
    }

    // Render net rating bar chart
    function renderNetRatingChart(teams) {
      const ctx = document.getElementById('netrating-chart');
      if (!ctx) return;

      // Destroy existing chart if it exists
      const existingChart = Chart.getChart(ctx);
      if (existingChart) {
        existingChart.destroy();
      }

      // Sort by net rating
      const sortedTeams = [...teams].sort((a, b) => parseFloat(b.netRating) - parseFloat(a.netRating));

      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: sortedTeams.map(t => t.team.name),
          datasets: [{
            label: 'Net Rating',
            data: sortedTeams.map(t => parseFloat(t.netRating)),
            backgroundColor: sortedTeams.map(t =>
              parseFloat(t.netRating) > 0 ? 'rgba(74, 222, 128, 0.6)' : 'rgba(248, 113, 113, 0.6)'
            ),
            borderColor: sortedTeams.map(t =>
              parseFloat(t.netRating) > 0 ? 'rgba(74, 222, 128, 1)' : 'rgba(248, 113, 113, 1)'
            ),
            borderWidth: 2
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(26, 26, 26, 0.95)',
              titleColor: '#BF5700',
              bodyColor: '#e0e0e0',
              borderColor: '#BF5700',
              borderWidth: 1,
              padding: 12,
              callbacks: {
                label: function(context) {
                  return `Net Rating: ${context.parsed.x > 0 ? '+' : ''}${context.parsed.x.toFixed(1)}`;
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Net Rating (Points per Game Differential)',
                color: '#BF5700',
                font: { size: 14, weight: 'bold' }
              },
              grid: {
                color: 'rgba(191, 87, 0, 0.1)'
              },
              ticks: {
                color: '#a0a0a0',
                callback: function(value) {
                  return value > 0 ? '+' + value : value;
                }
              }
            },
            y: {
              grid: {
                display: false
              },
              ticks: {
                color: '#a0a0a0',
                font: { size: 10 }
              }
            }
          }
        }
      });
    }

    // Render playoff probability chart
    function renderPlayoffProbabilityChart(teams) {
      const ctx = document.getElementById('playoff-chart');
      if (!ctx) return;

      // Destroy existing chart if it exists
      const existingChart = Chart.getChart(ctx);
      if (existingChart) {
        existingChart.destroy();
      }

      // Calculate playoff probability based on current pace
      const teamsWithProb = teams.map(t => {
        const gamesPlayed = t.record.wins + t.record.losses;
        const gamesRemaining = 82 - gamesPlayed;
        const currentPace = t.record.wins / gamesPlayed;
        const projectedWins = t.record.wins + (currentPace * gamesRemaining);

        // In NBA, typically need ~42-45 wins for 8th seed
        // Probability increases significantly above 45 wins
        let playoffProb;
        if (projectedWins >= 50) playoffProb = 95;
        else if (projectedWins >= 47) playoffProb = 85;
        else if (projectedWins >= 45) playoffProb = 70;
        else if (projectedWins >= 42) playoffProb = 50;
        else if (projectedWins >= 38) playoffProb = 25;
        else if (projectedWins >= 35) playoffProb = 10;
        else playoffProb = 2;

        return {
          name: t.team.name,
          playoffProb,
          projectedWins: projectedWins.toFixed(1),
          currentRecord: `${t.record.wins}-${t.record.losses}`
        };
      });

      // Sort by playoff probability
      const sortedTeams = teamsWithProb.sort((a, b) => b.playoffProb - a.playoffProb);

      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: sortedTeams.map(t => t.name),
          datasets: [{
            label: 'Playoff Probability (%)',
            data: sortedTeams.map(t => t.playoffProb),
            backgroundColor: sortedTeams.map(t =>
              t.playoffProb > 75 ? 'rgba(74, 222, 128, 0.6)' :
              t.playoffProb > 50 ? 'rgba(191, 87, 0, 0.6)' :
              t.playoffProb > 25 ? 'rgba(204, 102, 0, 0.6)' :
              'rgba(248, 113, 113, 0.6)'
            ),
            borderColor: sortedTeams.map(t =>
              t.playoffProb > 75 ? 'rgba(74, 222, 128, 1)' :
              t.playoffProb > 50 ? 'rgba(191, 87, 0, 1)' :
              t.playoffProb > 25 ? 'rgba(204, 102, 0, 1)' :
              'rgba(248, 113, 113, 1)'
            ),
            borderWidth: 2
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(26, 26, 26, 0.95)',
              titleColor: '#BF5700',
              bodyColor: '#e0e0e0',
              borderColor: '#BF5700',
              borderWidth: 1,
              padding: 12,
              callbacks: {
                label: function(context) {
                  const team = sortedTeams[context.dataIndex];
                  return [
                    `Playoff Probability: ${team.playoffProb}%`,
                    `Current Record: ${team.currentRecord}`,
                    `Projected Final: ${team.projectedWins} wins`
                  ];
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Playoff Probability (%)',
                color: '#BF5700',
                font: { size: 14, weight: 'bold' }
              },
              min: 0,
              max: 100,
              grid: {
                color: 'rgba(191, 87, 0, 0.1)'
              },
              ticks: {
                color: '#a0a0a0',
                callback: function(value) {
                  return value + '%';
                }
              }
            },
            y: {
              grid: {
                display: false
              },
              ticks: {
                color: '#a0a0a0',
                font: { size: 10 }
              }
            }
          }
        }
      });
    }

    // Show error message
    function showError(message) {
      const container = document.getElementById('standings-container');
      container.innerHTML = `
        <div class="error-message">
          <p><strong>‚ö†Ô∏è Error</strong></p>
          <p>${message}</p>
        </div>
      `;
    }

    // Generate demo data for testing (flat array structure)
    function generateDemoData() {
      const teamData = [
        { name: 'Boston Celtics', conf: 'Eastern', div: 'Atlantic' },
        { name: 'Philadelphia 76ers', conf: 'Eastern', div: 'Atlantic' },
        { name: 'Brooklyn Nets', conf: 'Eastern', div: 'Atlantic' },
        { name: 'New York Knicks', conf: 'Eastern', div: 'Atlantic' },
        { name: 'Toronto Raptors', conf: 'Eastern', div: 'Atlantic' },
        { name: 'Milwaukee Bucks', conf: 'Eastern', div: 'Central' },
        { name: 'Cleveland Cavaliers', conf: 'Eastern', div: 'Central' },
        { name: 'Chicago Bulls', conf: 'Eastern', div: 'Central' },
        { name: 'Indiana Pacers', conf: 'Eastern', div: 'Central' },
        { name: 'Detroit Pistons', conf: 'Eastern', div: 'Central' },
        { name: 'Miami Heat', conf: 'Eastern', div: 'Southeast' },
        { name: 'Orlando Magic', conf: 'Eastern', div: 'Southeast' },
        { name: 'Atlanta Hawks', conf: 'Eastern', div: 'Southeast' },
        { name: 'Charlotte Hornets', conf: 'Eastern', div: 'Southeast' },
        { name: 'Washington Wizards', conf: 'Eastern', div: 'Southeast' },
        { name: 'Oklahoma City Thunder', conf: 'Western', div: 'Northwest' },
        { name: 'Denver Nuggets', conf: 'Western', div: 'Northwest' },
        { name: 'Minnesota Timberwolves', conf: 'Western', div: 'Northwest' },
        { name: 'Portland Trail Blazers', conf: 'Western', div: 'Northwest' },
        { name: 'Utah Jazz', conf: 'Western', div: 'Northwest' },
        { name: 'Golden State Warriors', conf: 'Western', div: 'Pacific' },
        { name: 'LA Clippers', conf: 'Western', div: 'Pacific' },
        { name: 'Los Angeles Lakers', conf: 'Western', div: 'Pacific' },
        { name: 'Sacramento Kings', conf: 'Western', div: 'Pacific' },
        { name: 'Phoenix Suns', conf: 'Western', div: 'Pacific' },
        { name: 'Dallas Mavericks', conf: 'Western', div: 'Southwest' },
        { name: 'Memphis Grizzlies', conf: 'Western', div: 'Southwest' },
        { name: 'Houston Rockets', conf: 'Western', div: 'Southwest' },
        { name: 'New Orleans Pelicans', conf: 'Western', div: 'Southwest' },
        { name: 'San Antonio Spurs', conf: 'Western', div: 'Southwest' }
      ];

      const allTeams = teamData.map((team, idx) => {
        const wins = Math.floor(Math.random() * 30) + 10;
        const losses = Math.floor(Math.random() * 25) + 5;
        const gamesPlayed = wins + losses;
        const avgPointsFor = 105 + Math.random() * 15;
        const avgPointsAgainst = 105 + Math.random() * 15;
        const pointsFor = avgPointsFor * gamesPlayed;
        const pointsAgainst = avgPointsAgainst * gamesPlayed;

        return {
          rank: idx % 15 + 1,
          team: {
            id: team.name.toLowerCase().replace(/\s+/g, '-'),
            name: team.name,
            shortName: team.name.split(' ').pop(),
            abbreviation: team.name.substring(0, 3).toUpperCase()
          },
          conference: team.conf,
          division: team.div,
          record: {
            wins,
            losses,
            winPercentage: wins / gamesPlayed,
            gamesBack: idx % 15 * 1.5
          },
          homeRecord: `${Math.floor(wins * 0.6)}-${Math.floor(losses * 0.4)}`,
          awayRecord: `${Math.floor(wins * 0.4)}-${Math.floor(losses * 0.6)}`,
          conferenceRecord: `${Math.floor(wins * 0.6)}-${Math.floor(losses * 0.6)}`,
          divisionRecord: `${Math.floor(wins * 0.25)}-${Math.floor(losses * 0.25)}`,
          lastTenRecord: `${Math.floor(Math.random() * 6) + 4}-${10 - (Math.floor(Math.random() * 6) + 4)}`,
          streak: `${Math.random() > 0.5 ? 'W' : 'L'}${Math.floor(Math.random() * 5) + 1}`,
          pointsFor,
          pointsAgainst,
          avgPointsFor,
          avgPointsAgainst,
          netRating: (avgPointsFor - avgPointsAgainst).toFixed(1),
          pythag: calculatePythagorean(pointsFor, pointsAgainst, gamesPlayed, wins)
        };
      });

      // Sort by wins
      return allTeams.sort((a, b) => b.record.wins - a.record.wins);
    }
  </script>
</body>
</html>
