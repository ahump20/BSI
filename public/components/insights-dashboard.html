<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coaching & Umpire Insights - Blaze Sports Intel</title>
    <link rel="stylesheet" href="/css/bsi-tokens.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
      color: #ffffff;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      padding: 40px 20px;
      background: linear-gradient(135deg, rgba(255,107,0,0.1) 0%, rgba(255,107,0,0.05) 100%);
      border-radius: 20px;
      margin-bottom: 30px;
      border: 1px solid rgba(255,107,0,0.2);
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #ff6b00, #ff9500);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header p {
      font-size: 1.1rem;
      color: rgba(255,255,255,0.7);
    }

    .filters {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      background: rgba(255,255,255,0.05);
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 30px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .filter-group label {
      font-size: 0.9rem;
      color: rgba(255,255,255,0.7);
      font-weight: 500;
    }

    .filter-group select,
    .filter-group input {
      padding: 10px 15px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      background: rgba(0,0,0,0.3);
      color: #ffffff;
      font-size: 1rem;
      transition: all 0.3s ease;
    }

    .filter-group select:focus,
    .filter-group input:focus {
      outline: none;
      border-color: #ff6b00;
      background: rgba(0,0,0,0.5);
    }

    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 30px;
      background: rgba(255,255,255,0.05);
      padding: 10px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }

    .tab {
      flex: 1;
      padding: 15px 20px;
      background: transparent;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 10px;
      color: rgba(255,255,255,0.7);
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      font-weight: 500;
    }

    .tab:hover {
      background: rgba(255,107,0,0.1);
      border-color: rgba(255,107,0,0.3);
      color: #ffffff;
    }

    .tab.active {
      background: linear-gradient(135deg, #ff6b00, #ff9500);
      border-color: transparent;
      color: #ffffff;
      box-shadow: 0 4px 15px rgba(255,107,0,0.4);
    }

    .content {
      display: none;
    }

    .content.active {
      display: block;
    }

    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .card {
      background: rgba(255,255,255,0.05);
      border-radius: 15px;
      padding: 25px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }

    .card:hover {
      border-color: rgba(255,107,0,0.3);
      box-shadow: 0 8px 25px rgba(255,107,0,0.2);
      transform: translateY(-2px);
    }

    .card h3 {
      font-size: 1.3rem;
      margin-bottom: 15px;
      color: #ff6b00;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .card h3::before {
      content: '';
      width: 4px;
      height: 20px;
      background: linear-gradient(135deg, #ff6b00, #ff9500);
      border-radius: 2px;
    }

    .metric {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .metric:last-child {
      border-bottom: none;
    }

    .metric-label {
      color: rgba(255,255,255,0.7);
      font-size: 0.95rem;
    }

    .metric-value {
      font-size: 1.1rem;
      font-weight: 600;
      color: #ffffff;
    }

    .metric-value.good {
      color: #4ade80;
    }

    .metric-value.bad {
      color: #f87171;
    }

    .metric-value.neutral {
      color: #facc15;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
      overflow: hidden;
      margin-top: 8px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b00, #ff9500);
      border-radius: 4px;
      transition: width 0.5s ease;
    }

    .zone-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 15px;
    }

    .zone-cell {
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      font-size: 0.9rem;
      font-weight: 600;
      transition: all 0.3s ease;
      cursor: pointer;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .zone-cell:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .zone-cell.expanded {
      background: rgba(239, 68, 68, 0.3);
      border-color: rgba(239, 68, 68, 0.5);
    }

    .zone-cell.contracted {
      background: rgba(59, 130, 246, 0.3);
      border-color: rgba(59, 130, 246, 0.5);
    }

    .zone-cell.neutral {
      background: rgba(255,255,255,0.05);
    }

    .pattern-list {
      margin-top: 15px;
    }

    .pattern-item {
      background: rgba(255,255,255,0.03);
      padding: 12px 15px;
      border-radius: 8px;
      margin-bottom: 10px;
      border-left: 3px solid #ff6b00;
    }

    .pattern-item .pattern-title {
      font-weight: 600;
      margin-bottom: 5px;
      color: #ffffff;
    }

    .pattern-item .pattern-desc {
      font-size: 0.9rem;
      color: rgba(255,255,255,0.7);
    }

    .badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 0.85rem;
      font-weight: 600;
      margin-left: 8px;
    }

    .badge.exploitable {
      background: rgba(239, 68, 68, 0.2);
      color: #f87171;
      border: 1px solid rgba(239, 68, 68, 0.3);
    }

    .badge.consistent {
      background: rgba(34, 197, 94, 0.2);
      color: #4ade80;
      border: 1px solid rgba(34, 197, 94, 0.3);
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: rgba(255,255,255,0.5);
    }

    .loading::after {
      content: '...';
      animation: dots 1.5s steps(3, end) infinite;
    }

    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }

    .error {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      color: #f87171;
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: rgba(255,255,255,0.5);
    }

    .empty-state svg {
      width: 80px;
      height: 80px;
      margin-bottom: 20px;
      opacity: 0.3;
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 1.8rem;
      }

      .tabs {
        flex-direction: column;
      }

      .dashboard-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Coaching & Umpire Insights</h1>
      <p>Advanced analytics and pattern recognition for coaching decisions and umpire performance</p>
    </div>

    <div class="filters">
      <div class="filter-group">
        <label for="sportFilter">Sport</label>
        <select id="sportFilter">
          <option value="all">All Sports</option>
          <option value="MLB">MLB</option>
          <option value="NFL">NFL</option>
          <option value="NCAA_FOOTBALL">NCAA Football</option>
          <option value="NCAA_BASEBALL">NCAA Baseball</option>
        </select>
      </div>

      <div class="filter-group">
        <label for="teamFilter">Team</label>
        <input type="text" id="teamFilter" placeholder="Enter team name...">
      </div>

      <div class="filter-group">
        <label for="seasonFilter">Season</label>
        <select id="seasonFilter">
          <option value="2025">2025</option>
          <option value="2024">2024</option>
          <option value="2023">2023</option>
          <option value="2022">2022</option>
        </select>
      </div>

      <div class="filter-group">
        <label for="umpireFilter">Umpire (for umpire tab)</label>
        <input type="text" id="umpireFilter" placeholder="Enter umpire name...">
      </div>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="coaching">
        Coaching Analysis
      </div>
      <div class="tab" data-tab="umpire">
        Umpire Scorecards
      </div>
      <div class="tab" data-tab="patterns">
        Pattern Recognition
      </div>
    </div>

    <div id="coachingContent" class="content active">
      <div class="dashboard-grid">
        <div class="card">
          <h3>Decision Quality</h3>
          <div id="decisionQuality">
            <div class="loading">Loading decision quality metrics</div>
          </div>
        </div>

        <div class="card">
          <h3>4th Down Decisions</h3>
          <div id="fourthDownAnalysis">
            <div class="loading">Loading 4th down analysis</div>
          </div>
        </div>

        <div class="card">
          <h3>Risk Profile</h3>
          <div id="riskProfile">
            <div class="loading">Loading risk profile</div>
          </div>
        </div>

        <div class="card">
          <h3>Predictability Score</h3>
          <div id="predictability">
            <div class="loading">Loading predictability analysis</div>
          </div>
        </div>

        <div class="card">
          <h3>Play Calling Tendencies</h3>
          <div id="playCallingTendencies">
            <div class="loading">Loading play calling data</div>
          </div>
        </div>

        <div class="card">
          <h3>Situational Analysis</h3>
          <div id="situationalAnalysis">
            <div class="loading">Loading situational data</div>
          </div>
        </div>
      </div>
    </div>

    <div id="umpireContent" class="content">
      <div class="dashboard-grid">
        <div class="card">
          <h3>Overall Accuracy</h3>
          <div id="umpireAccuracy">
            <div class="loading">Loading accuracy metrics</div>
          </div>
        </div>

        <div class="card">
          <h3>Bias Detection</h3>
          <div id="umpirebias">
            <div class="loading">Loading bias analysis</div>
          </div>
        </div>

        <div class="card">
          <h3>Strike Zone Heat Map</h3>
          <div id="strikeZone">
            <div class="loading">Loading zone analysis</div>
          </div>
        </div>

        <div class="card">
          <h3>Consistency</h3>
          <div id="umpireConsistency">
            <div class="loading">Loading consistency metrics</div>
          </div>
        </div>

        <div class="card">
          <h3>Zone Tendencies</h3>
          <div id="zoneTendencies">
            <div class="loading">Loading zone tendencies</div>
          </div>
        </div>

        <div class="card">
          <h3>Game Flow</h3>
          <div id="gameFlow">
            <div class="loading">Loading game flow analysis</div>
          </div>
        </div>
      </div>
    </div>

    <div id="patternsContent" class="content">
      <div class="dashboard-grid">
        <div class="card">
          <h3>Detected Patterns</h3>
          <div id="detectedPatterns">
            <div class="loading">Loading pattern recognition</div>
          </div>
        </div>

        <div class="card">
          <h3>Sequential Patterns</h3>
          <div id="sequentialPatterns">
            <div class="loading">Loading sequential analysis</div>
          </div>
        </div>

        <div class="card">
          <h3>Exploitable Tendencies</h3>
          <div id="exploitableTendencies">
            <div class="loading">Loading exploitable patterns</div>
          </div>
        </div>

        <div class="card">
          <h3>Adaptation Analysis</h3>
          <div id="adaptationAnalysis">
            <div class="loading">Loading adaptation patterns</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Tab switching
    const tabs = document.querySelectorAll('.tab');
    const contents = document.querySelectorAll('.content');

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const target = tab.dataset.tab;

        tabs.forEach(t => t.classList.remove('active'));
        contents.forEach(c => c.classList.remove('active'));

        tab.classList.add('active');
        document.getElementById(`${target}Content`).classList.add('active');

        // Load data for active tab
        loadTabData(target);
      });
    });

    // Filter change handlers
    document.getElementById('sportFilter').addEventListener('change', refreshData);
    document.getElementById('teamFilter').addEventListener('input', debounce(refreshData, 500));
    document.getElementById('seasonFilter').addEventListener('change', refreshData);
    document.getElementById('umpireFilter').addEventListener('input', debounce(refreshData, 500));

    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    function getFilters() {
      return {
        sport: document.getElementById('sportFilter').value,
        team: document.getElementById('teamFilter').value,
        season: document.getElementById('seasonFilter').value,
        umpire: document.getElementById('umpireFilter').value
      };
    }

    function refreshData() {
      const activeTab = document.querySelector('.tab.active').dataset.tab;
      loadTabData(activeTab);
    }

    async function loadTabData(tab) {
      const filters = getFilters();

      switch (tab) {
        case 'coaching':
          await loadCoachingData(filters);
          break;
        case 'umpire':
          await loadUmpireData(filters);
          break;
        case 'patterns':
          await loadPatternData(filters);
          break;
      }
    }

    async function loadCoachingData(filters) {
      try {
        // Build query parameters
        const params = new URLSearchParams();
        if (filters.sport !== 'all') params.append('sport', filters.sport);
        if (filters.team) params.append('team', filters.team);
        if (filters.season) params.append('season', filters.season);

        // Fetch coaching decision data
        const response = await fetch(`/api/v1/coaching/decisions?${params}`);
        if (!response.ok) throw new Error('Failed to load coaching data');

        const data = await response.json();

        renderDecisionQuality(data.summary);
        renderFourthDownAnalysis(data.decisions.fourth_down);
        renderRiskProfile(data.risk_profile);
        renderPredictability(data.predictability);
        renderPlayCalling(data.decisions.play_calling);
        renderSituationalAnalysis(data.situational);

      } catch (error) {
        console.error('Error loading coaching data:', error);
        showError('coaching');
      }
    }

    function renderDecisionQuality(summary) {
      const container = document.getElementById('decisionQuality');

      if (!summary) {
        container.innerHTML = '<div class="empty-state">No decision data available</div>';
        return;
      }

      const qualityScore = summary.decision_quality_score || 0;
      const optimalRate = summary.total_decisions > 0
        ? Math.round((summary.optimal_decisions / summary.total_decisions) * 100)
        : 0;

      container.innerHTML = `
        <div class="metric">
          <span class="metric-label">Total Decisions</span>
          <span class="metric-value">${summary.total_decisions || 0}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Optimal Decisions</span>
          <span class="metric-value good">${summary.optimal_decisions || 0}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Suboptimal Decisions</span>
          <span class="metric-value bad">${summary.suboptimal_decisions || 0}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Optimal Rate</span>
          <span class="metric-value ${optimalRate > 60 ? 'good' : optimalRate > 40 ? 'neutral' : 'bad'}">${optimalRate}%</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" style="width: ${qualityScore}%"></div>
        </div>
      `;
    }

    function renderFourthDownAnalysis(fourthDown) {
      const container = document.getElementById('fourthDownAnalysis');

      if (!fourthDown || fourthDown.length === 0) {
        container.innerHTML = '<div class="empty-state">No 4th down decisions available</div>';
        return;
      }

      const total = fourthDown.length;
      const optimal = fourthDown.filter(d => d.is_optimal).length;
      const optimalRate = Math.round((optimal / total) * 100);

      const byAction = fourthDown.reduce((acc, d) => {
        const action = d.actual_decision || 'unknown';
        acc[action] = (acc[action] || 0) + 1;
        return acc;
      }, {});

      const actionsHTML = Object.entries(byAction)
        .sort((a, b) => b[1] - a[1])
        .map(([action, count]) => `
          <div class="metric">
            <span class="metric-label">${action.replace('_', ' ')}</span>
            <span class="metric-value">${count} (${Math.round((count / total) * 100)}%)</span>
          </div>
        `).join('');

      container.innerHTML = `
        <div class="metric">
          <span class="metric-label">Total 4th Down Attempts</span>
          <span class="metric-value">${total}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Optimal Decision Rate</span>
          <span class="metric-value ${optimalRate > 60 ? 'good' : optimalRate > 40 ? 'neutral' : 'bad'}">${optimalRate}%</span>
        </div>
        ${actionsHTML}
      `;
    }

    function renderRiskProfile(riskProfile) {
      const container = document.getElementById('riskProfile');

      if (!riskProfile) {
        container.innerHTML = '<div class="empty-state">No risk profile data available</div>';
        return;
      }

      const profileColor = riskProfile.profile === 'aggressive' ? 'bad'
        : riskProfile.profile === 'conservative' ? 'neutral'
        : 'good';

      container.innerHTML = `
        <div class="metric">
          <span class="metric-label">Profile</span>
          <span class="metric-value ${profileColor}">${riskProfile.profile.toUpperCase()}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Risk Score</span>
          <span class="metric-value">${riskProfile.risk_score}/100</span>
        </div>
        <div class="metric">
          <span class="metric-label">High Risk Decisions</span>
          <span class="metric-value bad">${riskProfile.risk_distribution.high_risk}%</span>
        </div>
        <div class="metric">
          <span class="metric-label">Medium Risk Decisions</span>
          <span class="metric-value neutral">${riskProfile.risk_distribution.medium_risk}%</span>
        </div>
        <div class="metric">
          <span class="metric-label">Low Risk Decisions</span>
          <span class="metric-value good">${riskProfile.risk_distribution.low_risk}%</span>
        </div>
      `;
    }

    function renderPredictability(predictability) {
      const container = document.getElementById('predictability');

      if (!predictability) {
        container.innerHTML = '<div class="empty-state">No predictability data available</div>';
        return;
      }

      const scoreColor = predictability.score > 75 ? 'bad'
        : predictability.score > 60 ? 'neutral'
        : 'good';

      container.innerHTML = `
        <div class="metric">
          <span class="metric-label">Predictability Score</span>
          <span class="metric-value ${scoreColor}">${predictability.score}/100</span>
        </div>
        <div class="metric">
          <span class="metric-label">Assessment</span>
          <span class="metric-value">${predictability.assessment.replace('_', ' ')}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Entropy</span>
          <span class="metric-value">${predictability.entropy}%</span>
        </div>
        <div class="metric">
          <span class="metric-label">Confidence</span>
          <span class="metric-value">${predictability.confidence}</span>
        </div>
        ${predictability.most_common_decision ? `
          <div class="metric">
            <span class="metric-label">Most Common Decision</span>
            <span class="metric-value">${predictability.most_common_decision.replace('_', ' ')}</span>
          </div>
        ` : ''}
        <div class="progress-bar">
          <div class="progress-fill" style="width: ${predictability.score}%"></div>
        </div>
      `;
    }

    function renderPlayCalling(playCalling) {
      const container = document.getElementById('playCallingTendencies');

      if (!playCalling) {
        container.innerHTML = '<div class="empty-state">No play calling data available</div>';
        return;
      }

      const runPassRatio = playCalling.run_plays / playCalling.pass_plays;

      container.innerHTML = `
        <div class="metric">
          <span class="metric-label">Total Plays</span>
          <span class="metric-value">${playCalling.total_plays}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Run Plays</span>
          <span class="metric-value">${playCalling.run_plays} (${Math.round((playCalling.run_plays / playCalling.total_plays) * 100)}%)</span>
        </div>
        <div class="metric">
          <span class="metric-label">Pass Plays</span>
          <span class="metric-value">${playCalling.pass_plays} (${Math.round((playCalling.pass_plays / playCalling.total_plays) * 100)}%)</span>
        </div>
        <div class="metric">
          <span class="metric-label">Run/Pass Ratio</span>
          <span class="metric-value">${runPassRatio.toFixed(2)}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Predictability Score</span>
          <span class="metric-value ${playCalling.predictability_score > 70 ? 'bad' : 'good'}">${playCalling.predictability_score}/100</span>
        </div>
      `;
    }

    function renderSituationalAnalysis(situational) {
      const container = document.getElementById('situationalAnalysis');

      if (!situational) {
        container.innerHTML = '<div class="empty-state">No situational data available</div>';
        return;
      }

      // For demo purposes, showing placeholder
      container.innerHTML = `
        <div class="empty-state">
          <p>Situational analysis will display tendencies by down, distance, field position, and game situation</p>
        </div>
      `;
    }

    async function loadUmpireData(filters) {
      try {
        const params = new URLSearchParams();
        if (filters.umpire) params.append('umpire', filters.umpire);
        if (filters.sport !== 'all') params.append('sport', filters.sport);
        if (filters.season) params.append('season', filters.season);

        const response = await fetch(`/api/v1/umpire/scorecard?${params}`);
        if (!response.ok) throw new Error('Failed to load umpire data');

        const data = await response.json();

        renderUmpireAccuracy(data.summary);
        renderUmpireBias(data.favor);
        renderStrikeZone(data.zones);
        renderUmpireConsistency(data.consistency);
        renderZoneTendencies(data.zones);
        renderGameFlow(data.consistency);

      } catch (error) {
        console.error('Error loading umpire data:', error);
        showError('umpire');
      }
    }

    function renderUmpireAccuracy(summary) {
      const container = document.getElementById('umpireAccuracy');

      if (!summary) {
        container.innerHTML = '<div class="empty-state">No umpire data available</div>';
        return;
      }

      const accuracy = summary.accuracy || 0;

      container.innerHTML = `
        <div class="metric">
          <span class="metric-label">Total Pitches</span>
          <span class="metric-value">${summary.total_pitches || 0}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Called Strikes</span>
          <span class="metric-value">${summary.called_strikes || 0}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Called Balls</span>
          <span class="metric-value">${summary.called_balls || 0}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Overall Accuracy</span>
          <span class="metric-value ${accuracy > 90 ? 'good' : accuracy > 85 ? 'neutral' : 'bad'}">${accuracy}%</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" style="width: ${accuracy}%"></div>
        </div>
      `;
    }

    function renderUmpireBias(favor) {
      const container = document.getElementById('umpirebias');

      if (!favor) {
        container.innerHTML = '<div class="empty-state">No bias data available</div>';
        return;
      }

      const biasText = favor.bias_detected
        ? `Bias detected favoring ${favor.home_favor ? 'HOME' : 'AWAY'}`
        : 'No significant bias detected';

      container.innerHTML = `
        <div class="metric">
          <span class="metric-label">Bias Status</span>
          <span class="metric-value ${favor.bias_detected ? 'bad' : 'good'}">${biasText}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Home Favor Score</span>
          <span class="metric-value">${favor.home_favor_score || 0}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Away Favor Score</span>
          <span class="metric-value">${favor.away_favor_score || 0}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Favor Differential</span>
          <span class="metric-value ${Math.abs(favor.favor_differential) > 5 ? 'bad' : 'good'}">${favor.favor_differential || 0}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Neutrality Score</span>
          <span class="metric-value">${favor.neutrality_score || 100}/100</span>
        </div>
      `;
    }

    function renderStrikeZone(zones) {
      const container = document.getElementById('strikeZone');

      if (!zones || !zones.zones) {
        container.innerHTML = '<div class="empty-state">No zone data available</div>';
        return;
      }

      const zoneData = zones.zones;
      const zoneNames = [
        ['high_inside', 'high_middle', 'high_outside'],
        ['middle_inside', 'middle_middle', 'middle_outside'],
        ['low_inside', 'low_middle', 'low_outside']
      ];

      let zoneHTML = '<div class="zone-grid">';

      for (const row of zoneNames) {
        for (const zoneName of row) {
          const zone = zoneData[zoneName];
          if (!zone) continue;

          const strikeRate = zone.strike_rate || 0;
          const expectedRate = getExpectedStrikeRate(zoneName);
          const deviation = strikeRate - expectedRate;

          let className = 'zone-cell neutral';
          if (Math.abs(deviation) > 5) {
            className = deviation > 0 ? 'zone-cell expanded' : 'zone-cell contracted';
          }

          zoneHTML += `
            <div class="${className}" title="${zoneName}: ${strikeRate}%">
              ${Math.round(strikeRate)}%
            </div>
          `;
        }
      }

      zoneHTML += '</div>';
      container.innerHTML = zoneHTML;
    }

    function getExpectedStrikeRate(zone) {
      const rates = {
        high_inside: 75, high_middle: 85, high_outside: 75,
        middle_inside: 85, middle_middle: 95, middle_outside: 85,
        low_inside: 75, low_middle: 85, low_outside: 75
      };
      return rates[zone] || 50;
    }

    function renderUmpireConsistency(consistency) {
      const container = document.getElementById('umpireConsistency');

      if (!consistency) {
        container.innerHTML = '<div class="empty-state">No consistency data available</div>';
        return;
      }

      const score = consistency.score || 0;

      container.innerHTML = `
        <div class="metric">
          <span class="metric-label">Consistency Score</span>
          <span class="metric-value ${score > 90 ? 'good' : score > 80 ? 'neutral' : 'bad'}">${score}/100</span>
        </div>
        <div class="metric">
          <span class="metric-label">Variance</span>
          <span class="metric-value">${consistency.variance || 0}%</span>
        </div>
        <div class="metric">
          <span class="metric-label">Trend</span>
          <span class="metric-value">${consistency.trend || 'N/A'}</span>
        </div>
        ${consistency.by_period ? `
          <div class="metric">
            <span class="metric-label">Early Game</span>
            <span class="metric-value">${consistency.by_period.first_third}%</span>
          </div>
          <div class="metric">
            <span class="metric-label">Mid Game</span>
            <span class="metric-value">${consistency.by_period.second_third}%</span>
          </div>
          <div class="metric">
            <span class="metric-label">Late Game</span>
            <span class="metric-value">${consistency.by_period.third_third}%</span>
          </div>
        ` : ''}
      `;
    }

    function renderZoneTendencies(zones) {
      const container = document.getElementById('zoneTendencies');

      if (!zones) {
        container.innerHTML = '<div class="empty-state">No zone tendency data available</div>';
        return;
      }

      const expanded = zones.favorable_zones || [];
      const contracted = zones.unfavorable_zones || [];

      let html = '';

      if (expanded.length > 0) {
        html += '<h4 style="margin-bottom: 10px; color: #f87171;">Expanded Zones</h4>';
        html += expanded.slice(0, 3).map(z => `
          <div class="metric">
            <span class="metric-label">${z.zone.replace('_', ' ')}</span>
            <span class="metric-value bad">+${z.deviation}%</span>
          </div>
        `).join('');
      }

      if (contracted.length > 0) {
        html += '<h4 style="margin: 15px 0 10px; color: #60a5fa;">Contracted Zones</h4>';
        html += contracted.slice(0, 3).map(z => `
          <div class="metric">
            <span class="metric-label">${z.zone.replace('_', ' ')}</span>
            <span class="metric-value">${z.deviation}%</span>
          </div>
        `).join('');
      }

      container.innerHTML = html || '<div class="empty-state">No significant zone tendencies</div>';
    }

    function renderGameFlow(consistency) {
      const container = document.getElementById('gameFlow');

      if (!consistency) {
        container.innerHTML = '<div class="empty-state">No game flow data available</div>';
        return;
      }

      const trend = consistency.trend || 'consistent';
      const trendText = trend === 'improving' ? 'Improves as game progresses'
        : trend === 'declining' ? 'Declines as game progresses'
        : 'Remains consistent throughout';

      container.innerHTML = `
        <div class="metric">
          <span class="metric-label">Game Flow Pattern</span>
          <span class="metric-value">${trendText}</span>
        </div>
      `;
    }

    async function loadPatternData(filters) {
      try {
        const params = new URLSearchParams();
        if (filters.sport !== 'all') params.append('sport', filters.sport);
        if (filters.team) params.append('team', filters.team);
        if (filters.season) params.append('season', filters.season);

        const response = await fetch(`/api/v1/patterns/analyze?${params}`);
        if (!response.ok) throw new Error('Failed to load pattern data');

        const data = await response.json();

        renderDetectedPatterns(data);
        renderSequentialPatterns(data.sequential);
        renderExploitableTendencies(data.exploitable);
        renderAdaptation(data.adaptation);

      } catch (error) {
        console.error('Error loading pattern data:', error);
        showError('patterns');
      }
    }

    function renderDetectedPatterns(data) {
      const container = document.getElementById('detectedPatterns');

      if (!data || !data.patterns) {
        container.innerHTML = '<div class="empty-state">No patterns detected</div>';
        return;
      }

      container.innerHTML = '<div class="pattern-list">' +
        data.patterns.slice(0, 5).map(pattern => `
          <div class="pattern-item">
            <div class="pattern-title">${pattern.type || 'Unknown Pattern'}</div>
            <div class="pattern-desc">${pattern.description || 'No description available'}</div>
            ${pattern.exploitable ? '<span class="badge exploitable">Exploitable</span>' : ''}
          </div>
        `).join('') +
        '</div>';
    }

    function renderSequentialPatterns(sequential) {
      const container = document.getElementById('sequentialPatterns');

      if (!sequential || !sequential.patterns || sequential.patterns.length === 0) {
        container.innerHTML = '<div class="empty-state">No sequential patterns detected</div>';
        return;
      }

      container.innerHTML = '<div class="pattern-list">' +
        sequential.patterns.slice(0, 5).map(pattern => `
          <div class="pattern-item">
            <div class="pattern-title">${pattern.pattern}</div>
            <div class="pattern-desc">Occurs ${pattern.occurrences} times (${Math.round((pattern.occurrences / sequential.patterns.length) * 100)}%)</div>
          </div>
        `).join('') +
        '</div>';
    }

    function renderExploitableTendencies(exploitable) {
      const container = document.getElementById('exploitableTendencies');

      if (!exploitable || exploitable.length === 0) {
        container.innerHTML = '<div class="empty-state">No exploitable tendencies detected</div>';
        return;
      }

      container.innerHTML = '<div class="pattern-list">' +
        exploitable.map(tendency => `
          <div class="pattern-item">
            <div class="pattern-title">${tendency.situation || tendency.type}
              <span class="badge exploitable">Exploitable</span>
            </div>
            <div class="pattern-desc">${tendency.description || `${tendency.action} ${tendency.percentage}% of the time`}</div>
          </div>
        `).join('') +
        '</div>';
    }

    function renderAdaptation(adaptation) {
      const container = document.getElementById('adaptationAnalysis');

      if (!adaptation || !adaptation.detected) {
        container.innerHTML = '<div class="empty-state">No adaptation patterns detected</div>';
        return;
      }

      container.innerHTML = `
        <div class="metric">
          <span class="metric-label">Adaptation Direction</span>
          <span class="metric-value">${adaptation.direction.replace('_', ' ')}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Magnitude</span>
          <span class="metric-value">${adaptation.magnitude}</span>
        </div>
        <div class="metric">
          <span class="metric-label">First Half Profile</span>
          <span class="metric-value">${adaptation.first_half}</span>
        </div>
        <div class="metric">
          <span class="metric-label">Second Half Profile</span>
          <span class="metric-value">${adaptation.second_half}</span>
        </div>
        ${adaptation.description ? `
          <div class="pattern-item">
            <div class="pattern-desc">${adaptation.description}</div>
          </div>
        ` : ''}
      `;
    }

    function showError(tab) {
      const sections = {
        coaching: ['decisionQuality', 'fourthDownAnalysis', 'riskProfile', 'predictability', 'playCallingTendencies', 'situationalAnalysis'],
        umpire: ['umpireAccuracy', 'umpirebias', 'strikeZone', 'umpireConsistency', 'zoneTendencies', 'gameFlow'],
        patterns: ['detectedPatterns', 'sequentialPatterns', 'exploitableTendencies', 'adaptationAnalysis']
      };

      sections[tab].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.innerHTML = '<div class="error">Failed to load data. Please try again.</div>';
        }
      });
    }

    // Initial load
    loadTabData('coaching');
  </script>
  <!-- Cookie Consent Banner (GDPR/CCPA Compliance) -->
  <script src="/components/cookie-banner.js"></script>
</body>
</html>
