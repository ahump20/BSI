/**
 * Newsletter Subscription API
 *
 * Stores subscriber emails in KV for first-party data collection.
 * No spam, no selling dataâ€”just keeping fans in the loop.
 */

interface Env {
  KV: KVNamespace;
}

interface SubscribeRequest {
  email: string;
}

export async function onRequestPost(context: { request: Request; env: Env }) {
  const { request, env } = context;

  // Parse request body
  let body: SubscribeRequest;
  try {
    body = await request.json();
  } catch {
    return new Response(JSON.stringify({ error: 'Invalid request body' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' },
    });
  }

  const { email } = body;

  // Validate email
  if (!email || typeof email !== 'string') {
    return new Response(JSON.stringify({ error: 'Email is required' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' },
    });
  }

  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return new Response(JSON.stringify({ error: 'Invalid email format' }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' },
    });
  }

  // Normalize email
  const normalizedEmail = email.toLowerCase().trim();

  // Store in KV with timestamp
  const subscriberData = {
    email: normalizedEmail,
    subscribedAt: new Date().toISOString(),
    source: 'footer',
  };

  try {
    // Use email as key (lowercase for deduplication)
    const key = 'newsletter:' + normalizedEmail;
    await env.KV.put(key, JSON.stringify(subscriberData));

    return new Response(
      JSON.stringify({
        success: true,
        message: "You're in. We'll keep it useful.",
      }),
      {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
      }
    );
  } catch (error) {
    console.error('Newsletter subscription error:', error);
    return new Response(JSON.stringify({ error: 'Failed to subscribe' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}
